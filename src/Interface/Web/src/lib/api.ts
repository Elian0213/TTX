//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.3.0.0 (NJsonSchema v11.2.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class TTXClient {
	private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
	private baseUrl: string;
	protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

	constructor(
		baseUrl?: string,
		http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }
	) {
		this.http = http ? http : (window as any);
		this.baseUrl = baseUrl ?? '';
	}

	/**
	 * @param page (optional)
	 * @param limit (optional)
	 * @param orderBy (optional)
	 * @param order (optional)
	 * @param searchBy (optional)
	 * @param search (optional)
	 * @return OK
	 */
	getCreators(
		page?: number | undefined,
		limit?: number | undefined,
		orderBy?: string | undefined,
		order?: string | undefined,
		searchBy?: string | undefined,
		search?: string | undefined
	): Promise<CreatorDtoDataPage> {
		let url_ = this.baseUrl + '/creators?';
		if (page === null) throw new Error("The parameter 'page' cannot be null.");
		else if (page !== undefined) url_ += 'page=' + encodeURIComponent('' + page) + '&';
		if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
		else if (limit !== undefined) url_ += 'limit=' + encodeURIComponent('' + limit) + '&';
		if (orderBy === null) throw new Error("The parameter 'orderBy' cannot be null.");
		else if (orderBy !== undefined) url_ += 'orderBy=' + encodeURIComponent('' + orderBy) + '&';
		if (order === null) throw new Error("The parameter 'order' cannot be null.");
		else if (order !== undefined) url_ += 'order=' + encodeURIComponent('' + order) + '&';
		if (searchBy === null) throw new Error("The parameter 'searchBy' cannot be null.");
		else if (searchBy !== undefined) url_ += 'searchBy=' + encodeURIComponent('' + searchBy) + '&';
		if (search === null) throw new Error("The parameter 'search' cannot be null.");
		else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetCreators(_response);
		});
	}

	protected processGetCreators(response: Response): Promise<CreatorDtoDataPage> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CreatorDtoDataPage.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<CreatorDtoDataPage>(null as any);
	}

	/**
	 * @param username (optional)
	 * @param ticker (optional)
	 * @return OK
	 */
	createCreator(username?: string | undefined, ticker?: string | undefined): Promise<Creator> {
		let url_ = this.baseUrl + '/creators?';
		if (username === null) throw new Error("The parameter 'username' cannot be null.");
		else if (username !== undefined) url_ += 'username=' + encodeURIComponent('' + username) + '&';
		if (ticker === null) throw new Error("The parameter 'ticker' cannot be null.");
		else if (ticker !== undefined) url_ += 'ticker=' + encodeURIComponent('' + ticker) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'POST',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCreateCreator(_response);
		});
	}

	protected processCreateCreator(response: Response): Promise<Creator> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = Creator.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<Creator>(null as any);
	}

	/**
	 * @return OK
	 */
	getCreator(slug: string): Promise<CreatorDto> {
		let url_ = this.baseUrl + '/creators/{slug}';
		if (slug === undefined || slug === null)
			throw new Error("The parameter 'slug' must be defined.");
		url_ = url_.replace('{slug}', encodeURIComponent('' + slug));
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetCreator(_response);
		});
	}

	protected processGetCreator(response: Response): Promise<CreatorDto> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CreatorDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<CreatorDto>(null as any);
	}

	/**
	 * @return OK
	 */
	getCreatorShares(creatorSlug: string): Promise<ShareDto[]> {
		let url_ = this.baseUrl + '/creators/{creatorSlug}/shares';
		if (creatorSlug === undefined || creatorSlug === null)
			throw new Error("The parameter 'creatorSlug' must be defined.");
		url_ = url_.replace('{creatorSlug}', encodeURIComponent('' + creatorSlug));
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetCreatorShares(_response);
		});
	}

	protected processGetCreatorShares(response: Response): Promise<ShareDto[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200) result200!.push(ShareDto.fromJS(item));
				} else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<ShareDto[]>(null as any);
	}

	/**
	 * @return OK
	 */
	getCreatorTransactions(creatorSlug: string): Promise<TransactionDtoListDto> {
		let url_ = this.baseUrl + '/creators/{creatorSlug}/transactions';
		if (creatorSlug === undefined || creatorSlug === null)
			throw new Error("The parameter 'creatorSlug' must be defined.");
		url_ = url_.replace('{creatorSlug}', encodeURIComponent('' + creatorSlug));
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetCreatorTransactions(_response);
		});
	}

	protected processGetCreatorTransactions(response: Response): Promise<TransactionDtoListDto> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = TransactionDtoListDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<TransactionDtoListDto>(null as any);
	}

	/**
	 * @param action (optional)
	 * @param amount (optional)
	 * @return OK
	 */
	createTransaction(
		creatorSlug: string,
		action?: string | undefined,
		amount?: number | undefined
	): Promise<Transaction> {
		let url_ = this.baseUrl + '/creators/{creatorSlug}/transactions?';
		if (creatorSlug === undefined || creatorSlug === null)
			throw new Error("The parameter 'creatorSlug' must be defined.");
		url_ = url_.replace('{creatorSlug}', encodeURIComponent('' + creatorSlug));
		if (action === null) throw new Error("The parameter 'action' cannot be null.");
		else if (action !== undefined) url_ += 'action=' + encodeURIComponent('' + action) + '&';
		if (amount === null) throw new Error("The parameter 'amount' cannot be null.");
		else if (amount !== undefined) url_ += 'amount=' + encodeURIComponent('' + amount) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'POST',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processCreateTransaction(_response);
		});
	}

	protected processCreateTransaction(response: Response): Promise<Transaction> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = Transaction.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<Transaction>(null as any);
	}

	/**
	 * @param step (optional)
	 * @param after (optional)
	 * @return OK
	 */
	getCreatorValueHistory(
		channelSlug: string,
		step?: TimeStep | undefined,
		after?: Date | undefined
	): Promise<CreatorValueDto> {
		let url_ = this.baseUrl + '/creators/{channelSlug}/value?';
		if (channelSlug === undefined || channelSlug === null)
			throw new Error("The parameter 'channelSlug' must be defined.");
		url_ = url_.replace('{channelSlug}', encodeURIComponent('' + channelSlug));
		if (step === null) throw new Error("The parameter 'step' cannot be null.");
		else if (step !== undefined) url_ += 'step=' + encodeURIComponent('' + step) + '&';
		if (after === null) throw new Error("The parameter 'after' cannot be null.");
		else if (after !== undefined)
			url_ += 'after=' + encodeURIComponent(after ? '' + after.toISOString() : '') + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetCreatorValueHistory(_response);
		});
	}

	protected processGetCreatorValueHistory(response: Response): Promise<CreatorValueDto> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = CreatorValueDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<CreatorValueDto>(null as any);
	}

	/**
	 * @return OK
	 */
	gamba(): Promise<GambaDto> {
		let url_ = this.baseUrl + '/gamba';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'POST',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGamba(_response);
		});
	}

	protected processGamba(response: Response): Promise<GambaDto> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = GambaDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<GambaDto>(null as any);
	}

	/**
	 * @param code (optional)
	 * @param state (optional)
	 * @return OK
	 */
	twitchCallback(code?: string | undefined, state?: string | undefined): Promise<TokenDto> {
		let url_ = this.baseUrl + '/sessions/twitch/callback?';
		if (code === null) throw new Error("The parameter 'code' cannot be null.");
		else if (code !== undefined) url_ += 'code=' + encodeURIComponent('' + code) + '&';
		if (state === null) throw new Error("The parameter 'state' cannot be null.");
		else if (state !== undefined) url_ += 'state=' + encodeURIComponent('' + state) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'text/plain'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processTwitchCallback(_response);
		});
	}

	protected processTwitchCallback(response: Response): Promise<TokenDto> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = TokenDto.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<TokenDto>(null as any);
	}

	/**
	 * @param page (optional)
	 * @param limit (optional)
	 * @param orderBy (optional)
	 * @param order (optional)
	 * @param searchBy (optional)
	 * @param search (optional)
	 * @return OK
	 */
	getUsers(
		page?: number | undefined,
		limit?: number | undefined,
		orderBy?: string | undefined,
		order?: string | undefined,
		searchBy?: string | undefined,
		search?: string | undefined
	): Promise<UserDataPage> {
		let url_ = this.baseUrl + '/users?';
		if (page === null) throw new Error("The parameter 'page' cannot be null.");
		else if (page !== undefined) url_ += 'page=' + encodeURIComponent('' + page) + '&';
		if (limit === null) throw new Error("The parameter 'limit' cannot be null.");
		else if (limit !== undefined) url_ += 'limit=' + encodeURIComponent('' + limit) + '&';
		if (orderBy === null) throw new Error("The parameter 'orderBy' cannot be null.");
		else if (orderBy !== undefined) url_ += 'orderBy=' + encodeURIComponent('' + orderBy) + '&';
		if (order === null) throw new Error("The parameter 'order' cannot be null.");
		else if (order !== undefined) url_ += 'order=' + encodeURIComponent('' + order) + '&';
		if (searchBy === null) throw new Error("The parameter 'searchBy' cannot be null.");
		else if (searchBy !== undefined) url_ += 'searchBy=' + encodeURIComponent('' + searchBy) + '&';
		if (search === null) throw new Error("The parameter 'search' cannot be null.");
		else if (search !== undefined) url_ += 'search=' + encodeURIComponent('' + search) + '&';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUsers(_response);
		});
	}

	protected processGetUsers(response: Response): Promise<UserDataPage> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = UserDataPage.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<UserDataPage>(null as any);
	}

	/**
	 * @return OK
	 */
	getSelf(): Promise<User> {
		let url_ = this.baseUrl + '/users/me';
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetSelf(_response);
		});
	}

	protected processGetSelf(response: Response): Promise<User> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = User.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<User>(null as any);
	}

	/**
	 * @return OK
	 */
	getUser(username: string): Promise<User> {
		let url_ = this.baseUrl + '/users/{username}';
		if (username === undefined || username === null)
			throw new Error("The parameter 'username' must be defined.");
		url_ = url_.replace('{username}', encodeURIComponent('' + username));
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUser(_response);
		});
	}

	protected processGetUser(response: Response): Promise<User> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				result200 = User.fromJS(resultData200);
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<User>(null as any);
	}

	/**
	 * @return OK
	 */
	getUserShares(username: string): Promise<ShareDto[]> {
		let url_ = this.baseUrl + '/users/{username}/shares';
		if (username === undefined || username === null)
			throw new Error("The parameter 'username' must be defined.");
		url_ = url_.replace('{username}', encodeURIComponent('' + username));
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUserShares(_response);
		});
	}

	protected processGetUserShares(response: Response): Promise<ShareDto[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200) result200!.push(ShareDto.fromJS(item));
				} else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<ShareDto[]>(null as any);
	}

	/**
	 * @return OK
	 */
	getUserTransactions(username: string): Promise<TransactionDto[]> {
		let url_ = this.baseUrl + '/users/{username}/transactions';
		if (username === undefined || username === null)
			throw new Error("The parameter 'username' must be defined.");
		url_ = url_.replace('{username}', encodeURIComponent('' + username));
		url_ = url_.replace(/[?&]$/, '');

		let options_: RequestInit = {
			method: 'GET',
			headers: {
				Accept: 'application/json'
			}
		};

		return this.http.fetch(url_, options_).then((_response: Response) => {
			return this.processGetUserTransactions(_response);
		});
	}

	protected processGetUserTransactions(response: Response): Promise<TransactionDto[]> {
		const status = response.status;
		let _headers: any = {};
		if (response.headers && response.headers.forEach) {
			response.headers.forEach((v: any, k: any) => (_headers[k] = v));
		}
		if (status === 200) {
			return response.text().then((_responseText) => {
				let result200: any = null;
				let resultData200 =
					_responseText === '' ? null : JSON.parse(_responseText, this.jsonParseReviver);
				if (Array.isArray(resultData200)) {
					result200 = [] as any;
					for (let item of resultData200) result200!.push(TransactionDto.fromJS(item));
				} else {
					result200 = <any>null;
				}
				return result200;
			});
		} else if (status !== 200 && status !== 204) {
			return response.text().then((_responseText) => {
				return throwException(
					'An unexpected server error occurred.',
					status,
					_responseText,
					_headers
				);
			});
		}
		return Promise.resolve<TransactionDto[]>(null as any);
	}
}

export class Creator implements ICreator {
	id!: number;
	created_at!: Date;
	updated_at!: Date;
	name!: string;
	slug!: string;
	ticker!: string;
	url!: string;
	avatar_url!: string;
	value!: number;
	is_live!: boolean;
	started_at?: Date | null;
	ended_at?: Date | null;

	constructor(data?: ICreator) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data['id'] !== undefined ? _data['id'] : <any>null;
			this.created_at = _data['created_at'] ? new Date(_data['created_at'].toString()) : <any>null;
			this.updated_at = _data['updated_at'] ? new Date(_data['updated_at'].toString()) : <any>null;
			this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
			this.slug = _data['slug'] !== undefined ? _data['slug'] : <any>null;
			this.ticker = _data['ticker'] !== undefined ? _data['ticker'] : <any>null;
			this.url = _data['url'] !== undefined ? _data['url'] : <any>null;
			this.avatar_url = _data['avatar_url'] !== undefined ? _data['avatar_url'] : <any>null;
			this.value = _data['value'] !== undefined ? _data['value'] : <any>null;
			this.is_live = _data['is_live'] !== undefined ? _data['is_live'] : <any>null;
			this.started_at = _data['started_at'] ? new Date(_data['started_at'].toString()) : <any>null;
			this.ended_at = _data['ended_at'] ? new Date(_data['ended_at'].toString()) : <any>null;
		}
	}

	static fromJS(data: any): Creator {
		data = typeof data === 'object' ? data : {};
		let result = new Creator();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['id'] = this.id !== undefined ? this.id : <any>null;
		data['created_at'] = this.created_at ? this.created_at.toISOString() : <any>null;
		data['updated_at'] = this.updated_at ? this.updated_at.toISOString() : <any>null;
		data['name'] = this.name !== undefined ? this.name : <any>null;
		data['slug'] = this.slug !== undefined ? this.slug : <any>null;
		data['ticker'] = this.ticker !== undefined ? this.ticker : <any>null;
		data['url'] = this.url !== undefined ? this.url : <any>null;
		data['avatar_url'] = this.avatar_url !== undefined ? this.avatar_url : <any>null;
		data['value'] = this.value !== undefined ? this.value : <any>null;
		data['is_live'] = this.is_live !== undefined ? this.is_live : <any>null;
		data['started_at'] = this.started_at ? this.started_at.toISOString() : <any>null;
		data['ended_at'] = this.ended_at ? this.ended_at.toISOString() : <any>null;
		return data;
	}
}

export interface ICreator {
	id: number;
	created_at: Date;
	updated_at: Date;
	name: string;
	slug: string;
	ticker: string;
	url: string;
	avatar_url: string;
	value: number;
	is_live: boolean;
	started_at?: Date | null;
	ended_at?: Date | null;
}

export class CreatorDto implements ICreatorDto {
	id!: number;
	name!: string;
	slug!: string;
	ticker!: string;
	url!: string;
	avatar_url!: string;
	value!: number;
	is_live!: boolean;
	started_at?: Date | null;
	ended_at?: Date | null;
	history!: Vote[];
	created_at!: Date;
	updated_at!: Date;

	constructor(data?: ICreatorDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
		if (!data) {
			this.history = [];
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data['id'] !== undefined ? _data['id'] : <any>null;
			this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
			this.slug = _data['slug'] !== undefined ? _data['slug'] : <any>null;
			this.ticker = _data['ticker'] !== undefined ? _data['ticker'] : <any>null;
			this.url = _data['url'] !== undefined ? _data['url'] : <any>null;
			this.avatar_url = _data['avatar_url'] !== undefined ? _data['avatar_url'] : <any>null;
			this.value = _data['value'] !== undefined ? _data['value'] : <any>null;
			this.is_live = _data['is_live'] !== undefined ? _data['is_live'] : <any>null;
			this.started_at = _data['started_at'] ? new Date(_data['started_at'].toString()) : <any>null;
			this.ended_at = _data['ended_at'] ? new Date(_data['ended_at'].toString()) : <any>null;
			if (Array.isArray(_data['history'])) {
				this.history = [] as any;
				for (let item of _data['history']) this.history!.push(Vote.fromJS(item));
			} else {
				this.history = <any>null;
			}
			this.created_at = _data['created_at'] ? new Date(_data['created_at'].toString()) : <any>null;
			this.updated_at = _data['updated_at'] ? new Date(_data['updated_at'].toString()) : <any>null;
		}
	}

	static fromJS(data: any): CreatorDto {
		data = typeof data === 'object' ? data : {};
		let result = new CreatorDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['id'] = this.id !== undefined ? this.id : <any>null;
		data['name'] = this.name !== undefined ? this.name : <any>null;
		data['slug'] = this.slug !== undefined ? this.slug : <any>null;
		data['ticker'] = this.ticker !== undefined ? this.ticker : <any>null;
		data['url'] = this.url !== undefined ? this.url : <any>null;
		data['avatar_url'] = this.avatar_url !== undefined ? this.avatar_url : <any>null;
		data['value'] = this.value !== undefined ? this.value : <any>null;
		data['is_live'] = this.is_live !== undefined ? this.is_live : <any>null;
		data['started_at'] = this.started_at ? this.started_at.toISOString() : <any>null;
		data['ended_at'] = this.ended_at ? this.ended_at.toISOString() : <any>null;
		if (Array.isArray(this.history)) {
			data['history'] = [];
			for (let item of this.history) data['history'].push(item.toJSON());
		}
		data['created_at'] = this.created_at ? this.created_at.toISOString() : <any>null;
		data['updated_at'] = this.updated_at ? this.updated_at.toISOString() : <any>null;
		return data;
	}
}

export interface ICreatorDto {
	id: number;
	name: string;
	slug: string;
	ticker: string;
	url: string;
	avatar_url: string;
	value: number;
	is_live: boolean;
	started_at?: Date | null;
	ended_at?: Date | null;
	history: Vote[];
	created_at: Date;
	updated_at: Date;
}

export class CreatorDtoDataPage implements ICreatorDtoDataPage {
	data!: CreatorDto[];
	total!: number;

	constructor(data?: ICreatorDtoDataPage) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
		if (!data) {
			this.data = [];
		}
	}

	init(_data?: any) {
		if (_data) {
			if (Array.isArray(_data['data'])) {
				this.data = [] as any;
				for (let item of _data['data']) this.data!.push(CreatorDto.fromJS(item));
			} else {
				this.data = <any>null;
			}
			this.total = _data['total'] !== undefined ? _data['total'] : <any>null;
		}
	}

	static fromJS(data: any): CreatorDtoDataPage {
		data = typeof data === 'object' ? data : {};
		let result = new CreatorDtoDataPage();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		if (Array.isArray(this.data)) {
			data['data'] = [];
			for (let item of this.data) data['data'].push(item.toJSON());
		}
		data['total'] = this.total !== undefined ? this.total : <any>null;
		return data;
	}
}

export interface ICreatorDtoDataPage {
	data: CreatorDto[];
	total: number;
}

export class CreatorRarity implements ICreatorRarity {
	id!: number;
	created_at!: Date;
	updated_at!: Date;
	name!: string;
	slug!: string;
	ticker!: string;
	url!: string;
	avatar_url!: string;
	value!: number;
	is_live!: boolean;
	started_at?: Date | null;
	ended_at?: Date | null;
	rarity!: Rarity;

	constructor(data?: ICreatorRarity) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data['id'] !== undefined ? _data['id'] : <any>null;
			this.created_at = _data['created_at'] ? new Date(_data['created_at'].toString()) : <any>null;
			this.updated_at = _data['updated_at'] ? new Date(_data['updated_at'].toString()) : <any>null;
			this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
			this.slug = _data['slug'] !== undefined ? _data['slug'] : <any>null;
			this.ticker = _data['ticker'] !== undefined ? _data['ticker'] : <any>null;
			this.url = _data['url'] !== undefined ? _data['url'] : <any>null;
			this.avatar_url = _data['avatar_url'] !== undefined ? _data['avatar_url'] : <any>null;
			this.value = _data['value'] !== undefined ? _data['value'] : <any>null;
			this.is_live = _data['is_live'] !== undefined ? _data['is_live'] : <any>null;
			this.started_at = _data['started_at'] ? new Date(_data['started_at'].toString()) : <any>null;
			this.ended_at = _data['ended_at'] ? new Date(_data['ended_at'].toString()) : <any>null;
			this.rarity = _data['rarity'] !== undefined ? _data['rarity'] : <any>null;
		}
	}

	static fromJS(data: any): CreatorRarity {
		data = typeof data === 'object' ? data : {};
		let result = new CreatorRarity();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['id'] = this.id !== undefined ? this.id : <any>null;
		data['created_at'] = this.created_at ? this.created_at.toISOString() : <any>null;
		data['updated_at'] = this.updated_at ? this.updated_at.toISOString() : <any>null;
		data['name'] = this.name !== undefined ? this.name : <any>null;
		data['slug'] = this.slug !== undefined ? this.slug : <any>null;
		data['ticker'] = this.ticker !== undefined ? this.ticker : <any>null;
		data['url'] = this.url !== undefined ? this.url : <any>null;
		data['avatar_url'] = this.avatar_url !== undefined ? this.avatar_url : <any>null;
		data['value'] = this.value !== undefined ? this.value : <any>null;
		data['is_live'] = this.is_live !== undefined ? this.is_live : <any>null;
		data['started_at'] = this.started_at ? this.started_at.toISOString() : <any>null;
		data['ended_at'] = this.ended_at ? this.ended_at.toISOString() : <any>null;
		data['rarity'] = this.rarity !== undefined ? this.rarity : <any>null;
		return data;
	}
}

export interface ICreatorRarity {
	id: number;
	created_at: Date;
	updated_at: Date;
	name: string;
	slug: string;
	ticker: string;
	url: string;
	avatar_url: string;
	value: number;
	is_live: boolean;
	started_at?: Date | null;
	ended_at?: Date | null;
	rarity: Rarity;
}

export class CreatorValueDto implements ICreatorValueDto {
	history!: Vote[];
	current_value!: number;

	constructor(data?: ICreatorValueDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
		if (!data) {
			this.history = [];
		}
	}

	init(_data?: any) {
		if (_data) {
			if (Array.isArray(_data['history'])) {
				this.history = [] as any;
				for (let item of _data['history']) this.history!.push(Vote.fromJS(item));
			} else {
				this.history = <any>null;
			}
			this.current_value =
				_data['current_value'] !== undefined ? _data['current_value'] : <any>null;
		}
	}

	static fromJS(data: any): CreatorValueDto {
		data = typeof data === 'object' ? data : {};
		let result = new CreatorValueDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		if (Array.isArray(this.history)) {
			data['history'] = [];
			for (let item of this.history) data['history'].push(item.toJSON());
		}
		data['current_value'] = this.current_value !== undefined ? this.current_value : <any>null;
		return data;
	}
}

export interface ICreatorValueDto {
	history: Vote[];
	current_value: number;
}

export class GambaDto implements IGambaDto {
	result!: CreatorRarity;
	rarities!: CreatorRarity[];

	constructor(data?: IGambaDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
		if (!data) {
			this.result = new CreatorRarity();
			this.rarities = [];
		}
	}

	init(_data?: any) {
		if (_data) {
			this.result = _data['result'] ? CreatorRarity.fromJS(_data['result']) : new CreatorRarity();
			if (Array.isArray(_data['rarities'])) {
				this.rarities = [] as any;
				for (let item of _data['rarities']) this.rarities!.push(CreatorRarity.fromJS(item));
			} else {
				this.rarities = <any>null;
			}
		}
	}

	static fromJS(data: any): GambaDto {
		data = typeof data === 'object' ? data : {};
		let result = new GambaDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['result'] = this.result ? this.result.toJSON() : <any>null;
		if (Array.isArray(this.rarities)) {
			data['rarities'] = [];
			for (let item of this.rarities) data['rarities'].push(item.toJSON());
		}
		return data;
	}
}

export interface IGambaDto {
	result: CreatorRarity;
	rarities: CreatorRarity[];
}

export enum Rarity {
	_0 = 0,
	_1 = 1,
	_2 = 2,
	_3 = 3
}

export class ShareDto implements IShareDto {
	creator!: Creator;
	user!: User;
	quantity!: number;

	constructor(data?: IShareDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
		if (!data) {
			this.creator = new Creator();
			this.user = new User();
		}
	}

	init(_data?: any) {
		if (_data) {
			this.creator = _data['creator'] ? Creator.fromJS(_data['creator']) : new Creator();
			this.user = _data['user'] ? User.fromJS(_data['user']) : new User();
			this.quantity = _data['quantity'] !== undefined ? _data['quantity'] : <any>null;
		}
	}

	static fromJS(data: any): ShareDto {
		data = typeof data === 'object' ? data : {};
		let result = new ShareDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['creator'] = this.creator ? this.creator.toJSON() : <any>null;
		data['user'] = this.user ? this.user.toJSON() : <any>null;
		data['quantity'] = this.quantity !== undefined ? this.quantity : <any>null;
		return data;
	}
}

export interface IShareDto {
	creator: Creator;
	user: User;
	quantity: number;
}

export enum TimeStep {
	_0 = 0,
	_1 = 1,
	_2 = 2,
	_3 = 3,
	_4 = 4,
	_5 = 5,
	_6 = 6
}

export class TokenDto implements ITokenDto {
	token!: string;

	constructor(data?: ITokenDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.token = _data['token'] !== undefined ? _data['token'] : <any>null;
		}
	}

	static fromJS(data: any): TokenDto {
		data = typeof data === 'object' ? data : {};
		let result = new TokenDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['token'] = this.token !== undefined ? this.token : <any>null;
		return data;
	}
}

export interface ITokenDto {
	token: string;
}

export class Transaction implements ITransaction {
	id!: number;
	created_at!: Date;
	updated_at!: Date;
	action!: TransactionAction;
	creator_id!: number;
	user_id!: number;
	quantity!: number;
	value!: number;

	constructor(data?: ITransaction) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data['id'] !== undefined ? _data['id'] : <any>null;
			this.created_at = _data['created_at'] ? new Date(_data['created_at'].toString()) : <any>null;
			this.updated_at = _data['updated_at'] ? new Date(_data['updated_at'].toString()) : <any>null;
			this.action = _data['action'] !== undefined ? _data['action'] : <any>null;
			this.creator_id = _data['creator_id'] !== undefined ? _data['creator_id'] : <any>null;
			this.user_id = _data['user_id'] !== undefined ? _data['user_id'] : <any>null;
			this.quantity = _data['quantity'] !== undefined ? _data['quantity'] : <any>null;
			this.value = _data['value'] !== undefined ? _data['value'] : <any>null;
		}
	}

	static fromJS(data: any): Transaction {
		data = typeof data === 'object' ? data : {};
		let result = new Transaction();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['id'] = this.id !== undefined ? this.id : <any>null;
		data['created_at'] = this.created_at ? this.created_at.toISOString() : <any>null;
		data['updated_at'] = this.updated_at ? this.updated_at.toISOString() : <any>null;
		data['action'] = this.action !== undefined ? this.action : <any>null;
		data['creator_id'] = this.creator_id !== undefined ? this.creator_id : <any>null;
		data['user_id'] = this.user_id !== undefined ? this.user_id : <any>null;
		data['quantity'] = this.quantity !== undefined ? this.quantity : <any>null;
		data['value'] = this.value !== undefined ? this.value : <any>null;
		return data;
	}
}

export interface ITransaction {
	id: number;
	created_at: Date;
	updated_at: Date;
	action: TransactionAction;
	creator_id: number;
	user_id: number;
	quantity: number;
	value: number;
}

export enum TransactionAction {
	_0 = 0,
	_1 = 1
}

export class TransactionDto implements ITransactionDto {
	readonly id!: number;
	action!: TransactionAction;
	readonly quantity!: number;
	readonly value!: number;
	creator!: Creator;
	user!: User;
	readonly created_at!: Date;
	readonly updated_at!: Date;

	constructor(data?: ITransactionDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
		if (!data) {
			this.creator = new Creator();
			this.user = new User();
		}
	}

	init(_data?: any) {
		if (_data) {
			(<any>this).id = _data['id'] !== undefined ? _data['id'] : <any>null;
			this.action = _data['action'] !== undefined ? _data['action'] : <any>null;
			(<any>this).quantity = _data['quantity'] !== undefined ? _data['quantity'] : <any>null;
			(<any>this).value = _data['value'] !== undefined ? _data['value'] : <any>null;
			this.creator = _data['creator'] ? Creator.fromJS(_data['creator']) : new Creator();
			this.user = _data['user'] ? User.fromJS(_data['user']) : new User();
			(<any>this).created_at = _data['created_at']
				? new Date(_data['created_at'].toString())
				: <any>null;
			(<any>this).updated_at = _data['updated_at']
				? new Date(_data['updated_at'].toString())
				: <any>null;
		}
	}

	static fromJS(data: any): TransactionDto {
		data = typeof data === 'object' ? data : {};
		let result = new TransactionDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['id'] = this.id !== undefined ? this.id : <any>null;
		data['action'] = this.action !== undefined ? this.action : <any>null;
		data['quantity'] = this.quantity !== undefined ? this.quantity : <any>null;
		data['value'] = this.value !== undefined ? this.value : <any>null;
		data['creator'] = this.creator ? this.creator.toJSON() : <any>null;
		data['user'] = this.user ? this.user.toJSON() : <any>null;
		data['created_at'] = this.created_at ? this.created_at.toISOString() : <any>null;
		data['updated_at'] = this.updated_at ? this.updated_at.toISOString() : <any>null;
		return data;
	}
}

export interface ITransactionDto {
	id: number;
	action: TransactionAction;
	quantity: number;
	value: number;
	creator: Creator;
	user: User;
	created_at: Date;
	updated_at: Date;
}

export class TransactionDtoListDto implements ITransactionDtoListDto {
	data!: TransactionDto[];

	constructor(data?: ITransactionDtoListDto) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
		if (!data) {
			this.data = [];
		}
	}

	init(_data?: any) {
		if (_data) {
			if (Array.isArray(_data['data'])) {
				this.data = [] as any;
				for (let item of _data['data']) this.data!.push(TransactionDto.fromJS(item));
			} else {
				this.data = <any>null;
			}
		}
	}

	static fromJS(data: any): TransactionDtoListDto {
		data = typeof data === 'object' ? data : {};
		let result = new TransactionDtoListDto();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		if (Array.isArray(this.data)) {
			data['data'] = [];
			for (let item of this.data) data['data'].push(item.toJSON());
		}
		return data;
	}
}

export interface ITransactionDtoListDto {
	data: TransactionDto[];
}

export class User implements IUser {
	id!: number;
	created_at!: Date;
	updated_at!: Date;
	twitch_id!: string;
	name!: string;
	avatar_url!: string;
	credits!: number;
	user_type!: UserType;

	constructor(data?: IUser) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.id = _data['id'] !== undefined ? _data['id'] : <any>null;
			this.created_at = _data['created_at'] ? new Date(_data['created_at'].toString()) : <any>null;
			this.updated_at = _data['updated_at'] ? new Date(_data['updated_at'].toString()) : <any>null;
			this.twitch_id = _data['twitch_id'] !== undefined ? _data['twitch_id'] : <any>null;
			this.name = _data['name'] !== undefined ? _data['name'] : <any>null;
			this.avatar_url = _data['avatar_url'] !== undefined ? _data['avatar_url'] : <any>null;
			this.credits = _data['credits'] !== undefined ? _data['credits'] : <any>null;
			this.user_type = _data['user_type'] !== undefined ? _data['user_type'] : <any>null;
		}
	}

	static fromJS(data: any): User {
		data = typeof data === 'object' ? data : {};
		let result = new User();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['id'] = this.id !== undefined ? this.id : <any>null;
		data['created_at'] = this.created_at ? this.created_at.toISOString() : <any>null;
		data['updated_at'] = this.updated_at ? this.updated_at.toISOString() : <any>null;
		data['twitch_id'] = this.twitch_id !== undefined ? this.twitch_id : <any>null;
		data['name'] = this.name !== undefined ? this.name : <any>null;
		data['avatar_url'] = this.avatar_url !== undefined ? this.avatar_url : <any>null;
		data['credits'] = this.credits !== undefined ? this.credits : <any>null;
		data['user_type'] = this.user_type !== undefined ? this.user_type : <any>null;
		return data;
	}
}

export interface IUser {
	id: number;
	created_at: Date;
	updated_at: Date;
	twitch_id: string;
	name: string;
	avatar_url: string;
	credits: number;
	user_type: UserType;
}

export class UserDataPage implements IUserDataPage {
	data!: User[];
	total!: number;

	constructor(data?: IUserDataPage) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
		if (!data) {
			this.data = [];
		}
	}

	init(_data?: any) {
		if (_data) {
			if (Array.isArray(_data['data'])) {
				this.data = [] as any;
				for (let item of _data['data']) this.data!.push(User.fromJS(item));
			} else {
				this.data = <any>null;
			}
			this.total = _data['total'] !== undefined ? _data['total'] : <any>null;
		}
	}

	static fromJS(data: any): UserDataPage {
		data = typeof data === 'object' ? data : {};
		let result = new UserDataPage();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		if (Array.isArray(this.data)) {
			data['data'] = [];
			for (let item of this.data) data['data'].push(item.toJSON());
		}
		data['total'] = this.total !== undefined ? this.total : <any>null;
		return data;
	}
}

export interface IUserDataPage {
	data: User[];
	total: number;
}

export enum UserType {
	_0 = 0,
	_1 = 1
}

export class Vote implements IVote {
	creator_id!: number;
	value!: number;
	time!: Date;

	constructor(data?: IVote) {
		if (data) {
			for (var property in data) {
				if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
			}
		}
	}

	init(_data?: any) {
		if (_data) {
			this.creator_id = _data['creator_id'] !== undefined ? _data['creator_id'] : <any>null;
			this.value = _data['value'] !== undefined ? _data['value'] : <any>null;
			this.time = _data['time'] ? new Date(_data['time'].toString()) : <any>null;
		}
	}

	static fromJS(data: any): Vote {
		data = typeof data === 'object' ? data : {};
		let result = new Vote();
		result.init(data);
		return result;
	}

	toJSON(data?: any) {
		data = typeof data === 'object' ? data : {};
		data['creator_id'] = this.creator_id !== undefined ? this.creator_id : <any>null;
		data['value'] = this.value !== undefined ? this.value : <any>null;
		data['time'] = this.time ? this.time.toISOString() : <any>null;
		return data;
	}
}

export interface IVote {
	creator_id: number;
	value: number;
	time: Date;
}

export class ApiException extends Error {
	override message: string;
	status: number;
	response: string;
	headers: { [key: string]: any };
	result: any;

	constructor(
		message: string,
		status: number,
		response: string,
		headers: { [key: string]: any },
		result: any
	) {
		super();

		this.message = message;
		this.status = status;
		this.response = response;
		this.headers = headers;
		this.result = result;
	}

	protected isApiException = true;

	static isApiException(obj: any): obj is ApiException {
		return obj.isApiException === true;
	}
}

function throwException(
	message: string,
	status: number,
	response: string,
	headers: { [key: string]: any },
	result?: any
): any {
	if (result !== null && result !== undefined) throw result;
	else throw new ApiException(message, status, response, headers, null);
}
